apply plugin: 'com.android.application'

android {
    compileSdkVersion rootProject.ext.android.compileSdkVersion
    defaultConfig {
        applicationId "com.army.gradletest"
        minSdkVersion rootProject.ext.android.minSdkVersion
        targetSdkVersion rootProject.ext.android.targetSdkVersion
        versionCode appVersionCode.toInteger()
        versionName appVersionName
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
    sourceSets {
        main {
            jniLibs.srcDirs = ['libs']
            res.srcDirs = [
                    'src/main/res',
                    'src/main/res-player'
            ]
        }
    }

    flavorDimensions "channel"

    productFlavors {
        yingyongbao {
            dimension "channel"
        }
        baidu {
            dimension "channel"
        }
    }
}

//为应用程序添加第三方库依赖
dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation rootProject.ext.dependence['appcompat-v7']
    implementation(rootProject.ext.dependence['constraint-layout']) {
        //移除库里的某个库
        exclude module: "support-v4"
        exclude group: "com.android.support"
        exclude group: "com.android.support", module: "support-v4"
        //禁止传递依赖，即当前项目无法调用本依赖库依赖的其他三方库
        transitive false
        //每次都从服务器拉取库文件
        changing = true
    }
    //只在编译期引入，打包的时候不会打进去
    compileOnly rootProject.ext.dependence.okhttp3
}

task("copyApkWindows") {
    doLast {
        //gradle执行阶段去执行
        def sourcePath = "E:\\Blog.zip"
        def destinationPath = "C:\\Users\\Army\\Desktop"
        def command = "copy ${sourcePath}/b ${destinationPath}"
        //在此方法中可以调用系统配置的命令
        //不知道为什么，windows下的copy命令一直报sourcePath指向的文件找不到
        //直接在命令行里执行该命令可以执行成功
        exec {
            try {
                workingDir "e:\\"
                commandLine command
                println('the command is execute success')
            } catch (GradleException e) {
                println('the command is execute failed')
            }
        }
    }
}

//没试过，不知道行不行，在Mac上面可以尝试
task("copyApkLinux") {
    doLast {
        //gradle执行阶段去执行
        def sourcePath = buildDir.absolutePath + "/outputs/apk/debug/app-debug.apk"
        def destinationPath = "/Users/Army/Downloads/"
        def command = "mv -f ${sourcePath} ${destinationPath}"
        exec {
            try {
                executable "bask"
                args "-c", command
                println('the command is execute success')
            } catch (GradleException e) {
                println('the command is execute failed')
            }
        }
    }
}

task helloTask(group: "army", description: "Test") {
    println "I am helloTask"
    doFirst {
        println "the first first"
    }
    doFirst {
        println "the second first"
    }
}
//在外面的后写的先执行
helloTask.doFirst {
    println "the out first"
}

helloTask.doFirst {
    println "the out first2"
}

tasks.create("helloTask2") {
    group = "army"
    description = "Test2"
    println "I am helloTask2"
}

//配置阶段执行完毕，能找到所以的task
afterEvaluate { project ->
    def startTime, buildTime
    def preBuild = project.tasks.getByName("preBuild")
    preBuild.doFirst {
        startTime = System.currentTimeMillis()
        println "startTime is ${startTime}"
    }
    def build = project.tasks.getByName("build")
    build.doLast {
        buildTime = System.currentTimeMillis() - startTime
        //单纯的编译时间
        println "buildTime is ${buildTime}"
    }
}

task taskX {
    println "taskX"
}

task taskY {
    println "taskY"
}

//task taskZ(dependsOn: taskX) {
//    println "taskZ"
//}
//task taskW(dependsOn: [taskX, taskY]) {
//    println "taskW"
//}
//符号<<的意思就是doLast

task lib1 << {
    println "lib1"
}
task lib2 << {
    println "lib2"
}
task nolib << {
    println "nolib"
}

task taskW {
    dependsOn project.tasks.findAll { task ->
        return task.name.startsWith("lib")
    }
    doLast {
        println "taskW"
    }
}
//taskW.dependsOn(taskX, taskY)

task handleXMLFile {
    def sourceFile = file("release.xml")
    def destDir = new File(buildDir, "generated/release/")
    if (!destDir.exists()) {
        destDir.mkdirs()
    }
    doLast {
        def releases = new XmlParser().parse(sourceFile)
        releases.release.each { release ->
            def versionName = release.versionName.text()
            def versionCode = release.versionCode.text()
            def versionInfo = release.versionInfo.text()
            def destFile = new File(destDir, "release_${versionName}.txt")
            destFile.write("${versionName} -> ${versionCode} -> ${versionInfo}")
        }
    }
}

task testHandleXMLFile(dependsOn: handleXMLFile) {
    def fileTree = fileTree(buildDir.absolutePath + "/generated/release/")
    fileTree.visit {
        println(it.name)
    }
}

apply from: "releaseinfo.gradle"

//mustRunAfter怎么用
task taskA {
    doLast {
        println "taskA"
    }
}

task taskB {
    mustRunAfter taskA
    doLast {
        println "taskB"
    }
}

task taskC {
    mustRunAfter taskB
    doLast {
        println "taskC"
    }
}

afterEvaluate {
    android.applicationVariants.all { variant ->
        println "variant.name = ${variant.name}"
        println "variant.baseName = ${variant.baseName}"
        println "variant.outputFile = ${variant.outputs.first().outputFile}"
    }
}

